import streamlit as st
import pandas as pd
import yfinance as yf
import pandas_ta as ta
import random
from datetime import datetime, timedelta

# --- AGENT CLASS DEFINITIONS (Copied from Colab) ---
# We are placing all our agent logic directly into the app script.

class Market_Analyst_Agent:
    def __init__(self):
        self.data = None
        self.logs = []

    def fetch_price_data(self, ticker, interval):
        self.logs.append(f"Fetching {interval} data for {ticker}...")
        end_date = datetime.now()
        start_date = end_date - timedelta(days=90)
        self.data = yf.download(tickers=ticker, start=start_date.strftime('%Y-%m-%d'), end=end_date.strftime('%Y-%m-%d'), interval=interval)
        if isinstance(self.data.columns, pd.MultiIndex):
            self.data.columns = self.data.columns.get_level_values(0)
        if self.data.empty:
            self.logs.append(f"FAILED to fetch data. The data frame is empty.")
            return False
        self.logs.append(f"Data fetched successfully. Shape: {self.data.shape}")
        return True

    def calculate_indicators(self):
        self.logs.append("Calculating technical indicators (RSI, MACD, Bollinger Bands)...")
        self.data.ta.rsi(append=True)
        self.data.ta.macd(append=True)
        self.data.ta.bbands(append=True)
        self.data.ta.sma(length=50, append=True)
        self.data.dropna(inplace=True)
        self.logs.append("Indicators calculated and added to data.")

    def get_market_sentiment(self):
        self.logs.append("Gauging market sentiment...")
        sentiments = ["bullish", "bearish", "neutral"]
        sentiment = random.choice(sentiments)
        self.logs.append(f"Simulated sentiment is '{sentiment}'.")
        return sentiment

    def check_economic_events(self):
        is_event_imminent = random.choice([True, False])
        if is_event_imminent:
            self.logs.append("VOLATILITY WARNING! A high-impact economic event is imminent.")
        else:
            self.logs.append("Economic calendar is clear.")
        return is_event_imminent

    def run_analysis(self, ticker, interval):
        if not self.fetch_price_data(ticker, interval):
            return None
        self.calculate_indicators()
        sentiment = self.get_market_sentiment()
        is_event = self.check_economic_events()
        return {'price_data': self.data, 'sentiment': sentiment, 'is_event_imminent': is_event, 'logs': self.logs}

class Strategy_Agent:
    def __init__(self):
        self.logs = []

    def find_trade_signal(self, processed_data):
        self.logs.append("Analyzing market data for trade signals...")
        if not processed_data:
            self.logs.append("No data received. Cannot find signals.")
            return None
        latest_data = processed_data['price_data'].iloc[-1]
        is_above_50ma = latest_data['Close'] > latest_data['SMA_50']
        is_macd_bullish = latest_data['MACD_12_26_9'] > latest_data['MACDs_12_26_9']
        prev_data = processed_data['price_data'].iloc[-2]
        was_macd_bullish = prev_data['MACD_12_26_9'] > prev_data['MACDs_12_26_9']
        if is_above_50ma and is_macd_bullish and not was_macd_bullish:
            self.logs.append("High-probability SWING signal found!")
            return {"signal_type": "BUY", "strategy": "Normal/Swing", "reason": "Price > SMA_50 and MACD bullish crossover.", "entry_price": latest_data['Close']}
        self.logs.append("No clear trade signals found at this time.")
        return None

class Risk_Manager_Agent:
    def __init__(self, account_balance=10000, risk_per_trade_percent=1):
        self.balance = account_balance
        self.risk_percent = risk_per_trade_percent
        self.logs = []
        self.logs.append(f"Initialized with account balance of ${self.balance:,.2f} and risk of {self.risk_percent}%.")

    def assess_trade(self, trade_signal, market_data):
        self.logs.append("Assessing trade signal...")
        if not trade_signal:
            return None
        if market_data['is_event_imminent']:
            self.logs.append("VETO: High-impact economic event is imminent.")
            return {"status": "VETOED", "reason": "High-impact economic event."}
        self.logs.append("Volatility check passed.")
        entry_price = trade_signal['entry_price']
        stop_loss = entry_price * 0.98
        take_profit = entry_price * 1.04
        potential_loss = entry_price - stop_loss
        potential_profit = take_profit - entry_price
        risk_reward_ratio = potential_profit / potential_loss
        self.logs.append(f"Potential Risk/Reward Ratio: 1:{risk_reward_ratio:.2f}")
        if risk_reward_ratio < 1.5:
            self.logs.append("VETO: Poor Risk/Reward Ratio.")
            return {"status": "VETOED", "reason": f"Poor Risk/Reward Ratio ({risk_reward_ratio:.2f})"}
        self.logs.append("Risk/Reward check passed.")
        capital_to_risk = self.balance * (self.risk_percent / 100)
        position_size = capital_to_risk / potential_loss
        self.logs.append(f"Position size calculated: {position_size:.4f} units.")
        return {"status": "APPROVED", "signal": trade_signal, "position_size": position_size, "stop_loss": stop_loss, "take_profit": take_profit}

class Execution_Agent:
    def __init__(self):
        self.logs = []

    def execute_trade(self, vetted_order):
        self.logs.append("Receiving vetted order...")
        if vetted_order and vetted_order['status'] == 'APPROVED':
            self.logs.append("--- EXECUTION LOG ---")
            self.logs.append(f"Action: {vetted_order['signal']['signal_type']}")
            self.logs.append(f"Strategy: {vetted_order['signal']['strategy']}")
            self.logs.append(f"Entry: ${vetted_order['signal']['entry_price']:.2f}")
            self.logs.append(f"Stop-Loss: ${vetted_order['stop_loss']:.2f}")
            self.logs.append(f"Take-Profit: ${vetted_order['take_profit']:.2f}")
            self.logs.append(f"Size: {vetted_order['position_size']:.4f} units")
            self.logs.append("--- ORDER PLACED (SIMULATED) ---")
        else:
            self.logs.append("Order was not approved. No action taken.")

# --- STREAMLIT WEB APP INTERFACE ---

st.set_page_config(layout="wide")
st.title("ðŸ“ˆ Multi-Agent AI Trading Crew Simulation")
st.write("This web app simulates a team of AI agents analyzing a stock to find trading opportunities. Enter a stock ticker and click 'Run Simulation' to see their process.")

# --- User Input ---
ticker = st.text_input("Enter Stock Ticker (e.g., AAPL, GOOG, MSFT)", "AAPL").upper()

if st.button("Run Simulation"):
    with st.spinner("The AI Crew is analyzing the market..."):
        # 1. Initialize Agents
        market_analyst = Market_Analyst_Agent()
        strategy_agent = Strategy_Agent()
        risk_manager = Risk_Manager_Agent()
        execution_agent = Execution_Agent()

        # 2. Run the analysis
        processed_data = market_analyst.run_analysis(ticker, interval="1d")

        # --- Display Agent Logs in Expanders ---
        with st.expander("ðŸ•µï¸ Market Analyst Agent Log", expanded=True):
            for log in market_analyst.logs:
                st.info(log)
            if processed_data and 'price_data' in processed_data:
                st.dataframe(processed_data['price_data'].tail())

        if processed_data:
            trade_signal = strategy_agent.find_trade_signal(processed_data)
            with st.expander("ðŸ§  Strategy Agent Log", expanded=True):
                for log in strategy_agent.logs:
                    st.info(log)

            if trade_signal:
                vetted_order = risk_manager.assess_trade(trade_signal, processed_data)
                with st.expander("ðŸ›¡ï¸ Risk Manager Agent Log", expanded=True):
                    for log in risk_manager.logs:
                        st.info(log)

                execution_agent.execute_trade(vetted_order)
                with st.expander("âœ‹ Execution Agent Log", expanded=True):
                    for log in execution_agent.logs:
                        st.info(log)
                
                # --- Display Final Result ---
                st.divider()
                if vetted_order and vetted_order['status'] == 'APPROVED':
                    st.success(f"âœ… FINAL DECISION: Trade APPROVED and Executed (Simulated).")
                else:
                    st.warning(f"âŒ FINAL DECISION: Trade VETOED. Reason: {vetted_order['reason']}")
            else:
                st.divider()
                st.warning("âš ï¸ FINAL DECISION: No viable trading signal was found.")
        else:
            st.divider()
            st.error("ðŸš¨ FAILED: Could not retrieve market data. Please check the ticker symbol or try again later.")